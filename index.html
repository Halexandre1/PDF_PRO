<!DOCTYPE html>
<html lang="pt-BR" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de PDF PRO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: #4f46e5;
        }
        body { 
            font-family: 'Inter', sans-serif; 
            transition: background-color 0.3s, color 0.3s;
        }
        .pdf-page.selected { 
            border-color: var(--accent-color); 
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.5); 
        }
        .pdf-container-wrapper::-webkit-scrollbar { display: none; }
        .pdf-container-wrapper { -ms-overflow-style: none; scrollbar-width: none; }
        .loader { 
            border-right-color: transparent !important; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        .pdf-page.dragging { opacity: 0.5; cursor: grabbing; }
        .pdf-page.drag-over { box-shadow: 0 0 0 4px var(--accent-color); }
        .drop-zone-highlight { 
            border-color: var(--accent-color) !important; 
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.5) !important; 
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 font-sans bg-slate-100 dark:bg-slate-900 text-slate-900 dark:text-slate-200">

    <div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl w-full max-w-5xl">
        <header class="flex justify-between items-start mb-4">
            <div class="flex items-center gap-4">
                <!-- ADICIONE O SEU LOGÓTIPO AQUI -->
                <img src="https://raw.githubusercontent.com/Halexandre1/PDF_PRO/main/HERBERT.jpg" alt="Logótipo do Editor de PDF PRO" class="w-12 h-12 rounded-md">
                <div>
                    <h2 class="text-3xl font-bold text-indigo-700 dark:text-indigo-400">Editor de PDF PRO</h2>
                    <p class="text-gray-600 dark:text-gray-400">Importe, junte, substitua, gire, reordene e salve os seus PDFs com facilidade.</p>
                </div>
            </div>
            <button id="themeToggle" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 flex items-center justify-center transition-transform hover:scale-110" aria-label="Alternar tema">🌙</button>
        </header>

        <section class="mb-6">
            <label for="importInput" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out w-full flex items-center justify-center gap-2">
                <i class="fas fa-file-import"></i> Importar PDF(s)
                <input type="file" id="importInput" accept=".pdf" class="hidden" multiple />
            </label>
        </section>

        <section class="flex flex-wrap items-center justify-center gap-4 mb-6 p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg">
            <button id="replaceButton" class="flex items-center justify-center bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-exchange-alt mr-2"></i> Substituir</button>
            <button id="rotateClockwiseButton" class="flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-redo-alt mr-2"></i> Girar 90°</button>
            <button id="rotateCounterClockwiseButton" class="flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-undo-alt mr-2"></i> Girar -90°</button>
            <button id="removeButton" class="flex items-center justify-center bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-trash-alt mr-2"></i> Remover</button>
            <button id="splitButton" class="flex items-center justify-center bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-cut mr-2"></i> Dividir</button>
        </section>
        
        <section class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <input type="text" id="fileNameInput" placeholder="Nome do ficheiro (ex: meu_documento.pdf)" class="flex-grow p-3 border border-gray-200 dark:border-slate-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-white dark:bg-slate-700" value="pdf_editado.pdf">
            <button id="downloadButton" class="flex items-center justify-center bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-save mr-2"></i> Salvar PDF</button>
        </section>

        <main id="pdfContainerWrapper" class="pdf-container-wrapper flex flex-wrap justify-center gap-4 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg border-2 border-dashed border-gray-300 dark:border-gray-600 min-h-[300px] max-h-[600px] overflow-y-auto transition-all duration-200 ease-in-out">
            <p id="initialMessage" class="text-gray-500 dark:text-gray-400 text-lg self-center">Arraste e solte um ou mais PDFs aqui.</p>
            <div id="pdfContainer" class="flex flex-wrap justify-center gap-4"></div>
        </main>
        <footer id="signature" class="text-center mt-4 text-sm text-gray-500 dark:text-gray-400"></footer>
    </div>

    <!-- Modal e Overlay de Carregamento -->
    <div id="customModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 hidden"><div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl max-w-sm w-full text-center"><p id="modalMessage" class="text-lg font-semibold mb-4"></p><button id="modalCloseButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300 ease-in-out">OK</button></div></div>
    <div id="loadingOverlay" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center z-50 hidden"><div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 mb-4" style="border-top-color: #6366f1;"></div><p id="loadingMessage" class="text-white text-xl font-semibold">A carregar...</p></div>

    <!-- Bibliotecas Externas -->
    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

    <script>
        /**
         * @file Editor de PDF Pro - Uma ferramenta de manipulação de PDF no lado do cliente.
         * @author HAlexandre
         * @version 2.3.0
         */

        // Configuração do worker da PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

        const DOM = {
            importInput: document.getElementById('importInput'),
            pdfContainer: document.getElementById('pdfContainer'),
            pdfContainerWrapper: document.getElementById('pdfContainerWrapper'),
            initialMessage: document.getElementById('initialMessage'),
            buttons: {
                rotateClockwise: document.getElementById('rotateClockwiseButton'),
                rotateCounterClockwise: document.getElementById('rotateCounterClockwiseButton'),
                remove: document.getElementById('removeButton'),
                split: document.getElementById('splitButton'),
                download: document.getElementById('downloadButton'),
                replace: document.getElementById('replaceButton'),
            },
            fileNameInput: document.getElementById('fileNameInput'),
            modal: {
                container: document.getElementById('customModal'),
                message: document.getElementById('modalMessage'),
                closeButton: document.getElementById('modalCloseButton')
            },
            loading: {
                overlay: document.getElementById('loadingOverlay'),
                message: document.getElementById('loadingMessage')
            },
            themeToggle: document.getElementById('themeToggle'),
            htmlEl: document.documentElement,
            signature: document.getElementById('signature')
        };

        const appState = {
            pdfDocOriginal: null,
            pdfDocLib: null,
            selectedPageIndices: [],
            draggedPageIndex: null
        };

        const UI = {
            showModal(message) {
                DOM.modal.message.textContent = message;
                DOM.modal.container.classList.remove('hidden');
            },
            hideModal() {
                DOM.modal.container.classList.add('hidden');
            },
            showLoading(message = 'A carregar...') {
                DOM.loading.message.textContent = message;
                DOM.loading.overlay.classList.remove('hidden');
            },
            hideLoading() {
                DOM.loading.overlay.classList.add('hidden');
            },
            updateButtonStates() {
                const isPdfLoaded = appState.pdfDocLib !== null;
                const selectedCount = appState.selectedPageIndices.length;
                DOM.buttons.rotateClockwise.disabled = selectedCount === 0;
                DOM.buttons.rotateCounterClockwise.disabled = selectedCount === 0;
                DOM.buttons.remove.disabled = selectedCount === 0;
                DOM.buttons.split.disabled = selectedCount === 0;
                DOM.buttons.replace.disabled = selectedCount !== 1;
                DOM.buttons.download.disabled = !isPdfLoaded;
                DOM.fileNameInput.disabled = !isPdfLoaded;
            },
            async renderPDFPages() {
                if (!appState.pdfDocOriginal) return;
                DOM.pdfContainer.innerHTML = '';
                appState.selectedPageIndices = [];

                for (let i = 0; i < appState.pdfDocOriginal.numPages; i++) {
                    const page = await appState.pdfDocOriginal.getPage(i + 1);
                    const viewport = page.getViewport({ scale: 0.4 });
                    const canvas = document.createElement('canvas');
                    canvas.getContext('2d').imageSmoothingQuality = 'high';
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'pdf-page border-2 border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer m-2 inline-block transition-all duration-200 ease-in-out hover:shadow-lg';
                    pageDiv.appendChild(canvas);
                    pageDiv.dataset.index = i;
                    pageDiv.draggable = true;

                    pageDiv.addEventListener('click', EventHandlers.onPageClick);
                    pageDiv.addEventListener('dragstart', EventHandlers.onDragStart);
                    pageDiv.addEventListener('dragover', EventHandlers.onDragOver);
                    pageDiv.addEventListener('dragleave', EventHandlers.onDragLeave);
                    pageDiv.addEventListener('drop', EventHandlers.onDropOnPage);
                    pageDiv.addEventListener('dragend', EventHandlers.onDragEnd);

                    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                    DOM.pdfContainer.appendChild(pageDiv);
                }
                this.updateButtonStates();
            },
            loadTheme() {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                    DOM.htmlEl.classList.add('dark');
                    DOM.themeToggle.innerHTML = '☀️';
                } else {
                    DOM.htmlEl.classList.remove('dark');
                    DOM.themeToggle.innerHTML = '🌙';
                }
            },
            setSignature() {
                const now = new Date();
                const year = now.getFullYear();
                DOM.signature.textContent = `Feito por HAlexandre © ${year}`;
            }
        };

        const PDF = {
            async updateDocs(pdfLibDoc) {
                appState.pdfDocLib = pdfLibDoc;
                const pdfBytes = await appState.pdfDocLib.save();
                const pdfBytesCopy = pdfBytes.slice(0);
                appState.pdfDocOriginal = await pdfjsLib.getDocument({ data: pdfBytesCopy }).promise;
                await UI.renderPDFPages();
            },
            /**
             * Carrega e processa ficheiros PDF de forma assíncrona para não bloquear a UI.
             * @param {File[]} files - Uma lista de ficheiros a serem carregados.
             */
            async loadFiles(files) {
                const isMerge = appState.pdfDocLib !== null;
                let currentDoc = isMerge ? appState.pdfDocLib : await PDFLib.PDFDocument.create();
                const totalFiles = files.length;

                // Função recursiva para processar um ficheiro de cada vez.
                const processFile = async (index) => {
                    // Condição de paragem: todos os ficheiros foram processados.
                    if (index >= totalFiles) {
                        try {
                            UI.showLoading('A finalizar e a renderizar...');
                            await this.updateDocs(currentDoc);
                            DOM.initialMessage.classList.add('hidden');
                            UI.showModal(`${totalFiles} ficheiro(s) processado(s) com sucesso!`);
                        } catch (e) {
                            console.error("Erro ao finalizar o documento:", e);
                            UI.showModal("Ocorreu um erro ao finalizar o documento.");
                        } finally {
                            UI.hideLoading();
                        }
                        return;
                    }

                    const file = files[index];
                    UI.showLoading(`A processar ficheiro ${index + 1} de ${totalFiles}: ${file.name}`);
                    
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const newPdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                        const copiedPages = await currentDoc.copyPages(newPdfDoc, newPdfDoc.getPageIndices());
                        copiedPages.forEach(page => currentDoc.addPage(page));

                        // Agenda o processamento do próximo ficheiro, libertando a thread da UI.
                        setTimeout(() => processFile(index + 1), 50);
                    } catch (error) {
                        console.error(`Erro ao processar o ficheiro ${file.name}:`, error);
                        UI.hideLoading();
                        UI.showModal(`Ocorreu um erro ao processar o ficheiro "${file.name}". O processo foi interrompido.`);
                    }
                };

                // Inicia o processamento com o primeiro ficheiro.
                processFile(0);
            },
            async rotatePages(angle) {
                if (appState.selectedPageIndices.length === 0) return UI.showModal("Selecione as páginas para girar.");
                UI.showLoading('A girar páginas...');
                appState.selectedPageIndices.forEach(index => {
                    const page = appState.pdfDocLib.getPage(index);
                    const currentRotation = page.getRotation().angle;
                    page.setRotation(PDFLib.degrees(currentRotation + angle));
                });
                await this.updateDocs(appState.pdfDocLib);
                UI.hideLoading();
                UI.showModal('Páginas giradas com sucesso!');
            },
            async removePages() {
                if (appState.selectedPageIndices.length === 0) return UI.showModal("Selecione as páginas para remover.");
                UI.showLoading('A remover páginas...');
                const sortedIndices = [...appState.selectedPageIndices].sort((a, b) => b - a);
                sortedIndices.forEach(index => appState.pdfDocLib.removePage(index));
                await this.updateDocs(appState.pdfDocLib);
                UI.hideLoading();
                UI.showModal('Páginas removidas com sucesso!');
            },
            async split() {
                if (appState.selectedPageIndices.length === 0) return UI.showModal("Selecione as páginas para criar um novo PDF.");
                UI.showLoading('A dividir PDF...');
                const newPdfDoc = await PDFLib.PDFDocument.create();
                const sortedIndices = [...appState.selectedPageIndices].sort((a, b) => a - b);
                const copiedPages = await newPdfDoc.copyPages(appState.pdfDocLib, sortedIndices);
                copiedPages.forEach(page => newPdfDoc.addPage(page));
                const pdfBytes = await newPdfDoc.save();
                this.download(pdfBytes, "pdf_dividido.pdf");
                UI.hideLoading();
                UI.showModal('Novo PDF criado com sucesso a partir das páginas selecionadas!');
            },
            async replacePage() {
                if (appState.selectedPageIndices.length !== 1) return UI.showModal("Por favor, selecione exatamente uma página para substituir.");
                
                const tempInput = document.createElement('input');
                tempInput.type = 'file';
                tempInput.accept = '.pdf';
                tempInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    UI.showLoading('A substituir página...');
                    try {
                        const pageIndexToReplace = appState.selectedPageIndices[0];
                        const arrayBuffer = await file.arrayBuffer();
                        const replacementPdf = await PDFLib.PDFDocument.load(arrayBuffer);
                        
                        const [copiedPage] = await appState.pdfDocLib.copyPages(replacementPdf, [0]);

                        appState.pdfDocLib.removePage(pageIndexToReplace);
                        appState.pdfDocLib.insertPage(pageIndexToReplace, copiedPage);

                        await this.updateDocs(appState.pdfDocLib);
                        UI.showModal('Página substituída com sucesso!');
                    } catch (error) {
                        console.error("Erro ao substituir página:", error);
                        UI.showModal("Erro ao substituir a página. Verifique o ficheiro de substituição.");
                    } finally {
                        UI.hideLoading();
                    }
                };
                tempInput.click();
            },
            download(bytes, defaultName) {
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                let fileName = DOM.fileNameInput.value.trim();
                if (!fileName) fileName = defaultName;
                if (!fileName.toLowerCase().endsWith('.pdf')) fileName += '.pdf';
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            },
            /**
             * Salva o documento PDF atual, com uma mensagem informativa para operações longas.
             */
            async save() {
                if (!appState.pdfDocLib) return UI.showModal("Nenhum PDF carregado para salvar.");

                UI.showLoading('A construir o PDF... Isto pode demorar, por favor, aguarde.');

                // Usa setTimeout para garantir que a UI atualiza a mensagem antes de iniciar a tarefa pesada.
                setTimeout(async () => {
                    try {
                        const pdfBytes = await appState.pdfDocLib.save();
                        this.download(pdfBytes, "pdf_editado.pdf");
                        UI.hideLoading();
                        UI.showModal("PDF salvo com sucesso!");
                    } catch (error) {
                        console.error("Erro ao salvar o PDF:", error);
                        UI.hideLoading();
                        UI.showModal("Ocorreu um erro ao salvar o PDF. Tente novamente.");
                    }
                }, 50);
            }
        };

        const EventHandlers = {
            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            },
            onPageClick(e) {
                const pageDiv = e.currentTarget;
                const clickedIndex = parseInt(pageDiv.dataset.index);
                const indexInSelection = appState.selectedPageIndices.indexOf(clickedIndex);
                if (indexInSelection > -1) {
                    appState.selectedPageIndices.splice(indexInSelection, 1);
                    pageDiv.classList.remove('selected');
                } else {
                    appState.selectedPageIndices.push(clickedIndex);
                    pageDiv.classList.add('selected');
                }
                UI.updateButtonStates();
            },
            onDragStart(e) {
                const pageElement = e.target.closest('.pdf-page');
                appState.draggedPageIndex = parseInt(pageElement.dataset.index);
                pageElement.classList.add('dragging');
            },
            onDragOver(e) {
                e.preventDefault();
                e.target.closest('.pdf-page')?.classList.add('drag-over');
            },
            onDragLeave(e) {
                e.target.closest('.pdf-page')?.classList.remove('drag-over');
            },
            async onDropOnPage(e) {
                e.preventDefault();
                const targetElement = e.target.closest('.pdf-page');
                targetElement?.classList.remove('drag-over');
                const targetIndex = parseInt(targetElement?.dataset.index);
                
                if (appState.draggedPageIndex !== null && targetIndex !== null && appState.draggedPageIndex !== targetIndex) {
                    UI.showLoading('A reordenar páginas...');
                    const [movedPage] = await appState.pdfDocLib.copyPages(appState.pdfDocLib, [appState.draggedPageIndex]);
                    appState.pdfDocLib.removePage(appState.draggedPageIndex);
                    appState.pdfDocLib.insertPage(targetIndex, movedPage);
                    await PDF.updateDocs(appState.pdfDocLib);
                    UI.hideLoading();
                }
            },
            onDragEnd(e) {
                e.target.closest('.pdf-page').classList.remove('dragging');
                appState.draggedPageIndex = null;
            },
            async onDropOnContainer(e) {
                DOM.pdfContainerWrapper.classList.remove('drop-zone-highlight');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
                if (files.length === 0) return UI.showModal("Por favor, solte apenas ficheiros PDF válidos.");
                await PDF.loadFiles(files);
            },
            setup() {
                DOM.importInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        PDF.loadFiles(Array.from(e.target.files));
                    }
                    e.target.value = '';
                });

                DOM.buttons.replace.addEventListener('click', PDF.replacePage);
                DOM.buttons.rotateClockwise.addEventListener('click', () => PDF.rotatePages(90));
                DOM.buttons.rotateCounterClockwise.addEventListener('click', () => PDF.rotatePages(-90));
                DOM.buttons.remove.addEventListener('click', PDF.removePages);
                DOM.buttons.split.addEventListener('click', PDF.split);
                DOM.buttons.download.addEventListener('click', PDF.save);

                DOM.modal.closeButton.addEventListener('click', UI.hideModal);
                DOM.themeToggle.addEventListener('click', () => {
                    DOM.htmlEl.classList.toggle('dark');
                    const isDark = DOM.htmlEl.classList.contains('dark');
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                    DOM.themeToggle.innerHTML = isDark ? '☀️' : '🌙';
                });

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    document.body.addEventListener(eventName, this.preventDefaults, false);
                });
                DOM.pdfContainerWrapper.addEventListener('dragenter', () => DOM.pdfContainerWrapper.classList.add('drop-zone-highlight'), false);
                DOM.pdfContainerWrapper.addEventListener('dragleave', () => DOM.pdfContainerWrapper.classList.remove('drop-zone-highlight'), false);
                DOM.pdfContainerWrapper.addEventListener('drop', this.onDropOnContainer, false);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            UI.updateButtonStates();
            UI.loadTheme();
            UI.setSignature();
            EventHandlers.setup();
        });
    </script>
</body>
</html>
