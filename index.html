<!DOCTYPE html>
<html lang="pt-BR" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de PDF PRO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script>
        // Configuração do Tailwind para usar a classe 'dark'
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <style>
        :root { --accent-color: #4f46e5; }
        body { font-family: 'Inter', sans-serif; transition: background-color 0.3s, color 0.3s; }
        .pdf-page {
            position: relative; /* Mantido para posicionar elementos filhos */
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out; /* Adicionado para animar a seleção */
        }
        .pdf-page.selected {
            border-color: var(--accent-color);
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.4); /* Sombra mais destacada */
            transform: scale(1.03); /* Efeito de zoom suave */
        }
        .pdf-container-wrapper::-webkit-scrollbar { display: none; }
        .pdf-container-wrapper { -ms-overflow-style: none; scrollbar-width: none; }
        .loader { border-right-color: transparent !important; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .pdf-page.dragging { opacity: 0.5; cursor: grabbing; }
        .pdf-page.drag-over { box-shadow: 0 0 0 4px var(--accent-color); }
        .drop-zone-highlight { border-color: var(--accent-color) !important; box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.5) !important; }
        .page-number {
            position: absolute;
            bottom: 8px;
            left: 8px; /* Movido para a esquerda para não conflitar com o check */
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 8px;
            border-radius: 9999px; /* pill shape */
            font-size: 12px;
            font-weight: 500;
            pointer-events: none; /* Garante que o número não interfira com cliques na página */
            z-index: 5;
        }

        /* NOVO: Estilo para o indicador de seleção (check mark) */
        .selection-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            background-color: var(--accent-color);
            color: white;
            border-radius: 50%;
            display: none; /* Escondido por padrão */
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
            border: 2px solid white;
        }

        /* Mostra o indicador quando a página está selecionada */
        .pdf-page.selected .selection-indicator {
            display: flex;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 font-sans bg-slate-100 dark:bg-slate-900 text-slate-900 dark:text-slate-200">

    <div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl w-full max-w-5xl">
        <header class="flex justify-between items-start mb-4">
            <div class="flex items-center gap-4">
                <img src="https://raw.githubusercontent.com/Halexandre1/PDF_PRO/main/HERBERT.jpg" alt="Logótipo do Editor de PDF PRO" class="w-12 h-12 rounded-md">
                <div>
                    <h2 class="text-3xl font-bold text-indigo-700 dark:text-indigo-400">Editor de PDF PRO</h2>
                    <p class="text-gray-600 dark:text-gray-400">Importe, junte, substitua, gire, reordene e salve os seus PDFs com facilidade.</p>
                </div>
            </div>
            <button id="themeToggle" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 flex items-center justify-center transition-transform hover:scale-110" aria-label="Alternar tema">🌙</button>
        </header>

        <section class="mb-6">
            <label for="importInput" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out w-full flex items-center justify-center gap-2">
                <i class="fas fa-file-import"></i> Importar PDF(s)
                <input type="file" id="importInput" accept=".pdf" class="hidden" multiple />
            </label>
        </section>

        <section class="flex flex-wrap items-center justify-center gap-4 mb-6 p-4 bg-gray-50 dark:bg-slate-800/50 rounded-lg">
            <button id="replaceButton" class="flex items-center justify-center bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-exchange-alt mr-2"></i> Substituir</button>
            <button id="rotateClockwiseButton" class="flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-redo-alt mr-2"></i> Girar 90°</button>
            <button id="rotateCounterClockwiseButton" class="flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-undo-alt mr-2"></i> Girar -90°</button>
            <button id="removeButton" class="flex items-center justify-center bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-trash-alt mr-2"></i> Remover</button>
            <button id="splitButton" class="flex items-center justify-center bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-cut mr-2"></i> Dividir</button>
        </section>
        
        <section class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <input type="text" id="fileNameInput" placeholder="Nome do ficheiro (ex: meu_documento.pdf)" class="flex-grow p-3 border border-gray-200 dark:border-slate-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-white dark:bg-slate-700" value="pdf_editado.pdf">
            <button id="downloadButton" class="flex items-center justify-center bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled><i class="fas fa-save mr-2"></i> Salvar PDF</button>
        </section>

        <main id="pdfContainerWrapper" class="pdf-container-wrapper flex flex-wrap justify-center gap-4 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg border-2 border-dashed border-gray-300 dark:border-gray-600 min-h-[300px] max-h-[600px] overflow-y-auto transition-all duration-200 ease-in-out">
            <p id="initialMessage" class="text-gray-500 dark:text-gray-400 text-lg self-center">Arraste e solte um ou mais PDFs aqui.</p>
            <div id="pdfContainer" class="flex flex-wrap justify-center gap-4"></div>
        </main>
        <footer id="signature" class="text-center mt-4 text-sm text-gray-500 dark:text-gray-400"></footer>
    </div>

    <!-- Modal e Overlay de Carregamento -->
    <div id="customModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 hidden"><div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl max-w-sm w-full text-center"><p id="modalMessage" class="text-lg font-semibold mb-4"></p><button id="modalCloseButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300 ease-in-out">OK</button></div></div>
    <div id="loadingOverlay" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center z-50 hidden"><div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 mb-4" style="border-top-color: #6366f1;"></div><p id="loadingMessage" class="text-white text-xl font-semibold">A carregar...</p></div>

    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    
    <script id="pdfWorker" type="javascript/worker">
        self.importScripts('https://unpkg.com/pdf-lib/dist/pdf-lib.min.js');

        let pdfDoc = null;

        self.onmessage = async (event) => {
            const { type, payload } = event.data;

            try {
                switch (type) {
                    case 'LOAD_FILES': {
                        const { files } = payload;
                        if (!pdfDoc) {
                            pdfDoc = await self.PDFLib.PDFDocument.create();
                        }
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            self.postMessage({ type: 'PROGRESS', payload: { message: `A processar ficheiro ${i + 1} de ${files.length}: ${file.name}` } });
                            const arrayBuffer = await file.arrayBuffer();
                            const newPdfDoc = await self.PDFLib.PDFDocument.load(arrayBuffer);
                            const copiedPages = await pdfDoc.copyPages(newPdfDoc, newPdfDoc.getPageIndices());
                            copiedPages.forEach(page => pdfDoc.addPage(page));
                        }
                        const pdfBytes = await pdfDoc.save();
                        self.postMessage({ type: 'LOAD_SUCCESS', payload: { pdfBytes } });
                        break;
                    }
                    case 'ROTATE': {
                        const { indices, angle } = payload;
                        indices.forEach(index => {
                            const page = pdfDoc.getPage(index);
                            const currentRotation = page.getRotation().angle;
                            page.setRotation(self.PDFLib.degrees(currentRotation + angle));
                        });
                        const pdfBytes = await pdfDoc.save();
                        self.postMessage({ type: 'OPERATION_SUCCESS', payload: { pdfBytes, message: 'Páginas giradas com sucesso!' } });
                        break;
                    }
                    case 'REMOVE': {
                        const { indices } = payload;
                        const sortedIndices = [...indices].sort((a, b) => b - a);
                        sortedIndices.forEach(index => pdfDoc.removePage(index));
                        const pdfBytes = await pdfDoc.save();
                        self.postMessage({ type: 'OPERATION_SUCCESS', payload: { pdfBytes, message: 'Páginas removidas com sucesso!' } });
                        break;
                    }
                    case 'REORDER': {
                        const { fromIndex, toIndex } = payload;
                        const [movedPage] = await pdfDoc.copyPages(pdfDoc, [fromIndex]);
                        pdfDoc.removePage(fromIndex);
                        const insertIndex = fromIndex < toIndex ? toIndex -1 : toIndex;
                        pdfDoc.insertPage(insertIndex, movedPage);
                        const pdfBytes = await pdfDoc.save();
                        self.postMessage({ type: 'OPERATION_SUCCESS', payload: { pdfBytes } });
                        break;
                    }
                     case 'REPLACE': {
                        const { index, file } = payload;
                        const arrayBuffer = await file.arrayBuffer();
                        const replacementPdf = await self.PDFLib.PDFDocument.load(arrayBuffer);
                        if (replacementPdf.getPageCount() === 0) {
                            throw new Error("O PDF de substituição não tem páginas.");
                        }
                        const [copiedPage] = await pdfDoc.copyPages(replacementPdf, [0]);
                        pdfDoc.removePage(index);
                        pdfDoc.insertPage(index, copiedPage);
                        const pdfBytes = await pdfDoc.save();
                        self.postMessage({ type: 'OPERATION_SUCCESS', payload: { pdfBytes, message: 'Página substituída com sucesso!' } });
                        break;
                    }
                    case 'SPLIT': {
                        const { indices } = payload;
                        const newPdfDoc = await self.PDFLib.PDFDocument.create();
                        const sortedIndices = [...indices].sort((a, b) => a - b);
                        const copiedPages = await newPdfDoc.copyPages(pdfDoc, sortedIndices);
                        copiedPages.forEach(page => newPdfDoc.addPage(page));
                        const pdfBytes = await newPdfDoc.save();
                        self.postMessage({ type: 'SPLIT_SUCCESS', payload: { pdfBytes } });
                        break;
                    }
                    case 'SAVE': {
                        const pdfBytes = await pdfDoc.save();
                        self.postMessage({ type: 'SAVE_SUCCESS', payload: { pdfBytes } });
                        break;
                    }
                }
            } catch (error) {
                console.error('Erro no Worker:', error);
                self.postMessage({ type: 'ERROR', payload: { message: `Ocorreu um erro no worker: ${error.message}` } });
            }
        };
    </script>

    <script>
        /**
         * @file Editor de PDF Pro - Versão Final Revisada
         * @author HAlexandre
         * @version 3.1.1
         */

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

        const DOM = {
            importInput: document.getElementById('importInput'),
            pdfContainer: document.getElementById('pdfContainer'),
            pdfContainerWrapper: document.getElementById('pdfContainerWrapper'),
            initialMessage: document.getElementById('initialMessage'),
            buttons: {
                rotateClockwise: document.getElementById('rotateClockwiseButton'),
                rotateCounterClockwise: document.getElementById('rotateCounterClockwiseButton'),
                remove: document.getElementById('removeButton'),
                split: document.getElementById('splitButton'),
                download: document.getElementById('downloadButton'),
                replace: document.getElementById('replaceButton'),
            },
            fileNameInput: document.getElementById('fileNameInput'),
            modal: { container: document.getElementById('customModal'), message: document.getElementById('modalMessage'), closeButton: document.getElementById('modalCloseButton') },
            loading: { overlay: document.getElementById('loadingOverlay'), message: document.getElementById('loadingMessage') },
            themeToggle: document.getElementById('themeToggle'),
            htmlEl: document.documentElement,
            signature: document.getElementById('signature')
        };

        const appState = {
            pdfDocOriginal: null,
            selectedPageIndices: new Set(),
            draggedPageIndex: null,
            pdfWorker: null
        };

        const UI = {
            showModal(message) { DOM.modal.message.textContent = message; DOM.modal.container.classList.remove('hidden'); },
            hideModal() { DOM.modal.container.classList.add('hidden'); },
            showLoading(message = 'A carregar...') { DOM.loading.message.textContent = message; DOM.loading.overlay.classList.remove('hidden'); },
            hideLoading() { DOM.loading.overlay.classList.add('hidden'); },
            updateButtonStates() {
                const isPdfLoaded = appState.pdfDocOriginal !== null;
                const selectedCount = appState.selectedPageIndices.size;
                Object.values(DOM.buttons).forEach(btn => btn.disabled = !isPdfLoaded);
                DOM.buttons.rotateClockwise.disabled = selectedCount === 0;
                DOM.buttons.rotateCounterClockwise.disabled = selectedCount === 0;
                DOM.buttons.remove.disabled = selectedCount === 0;
                DOM.buttons.split.disabled = selectedCount === 0;
                DOM.buttons.replace.disabled = selectedCount !== 1;
                DOM.fileNameInput.disabled = !isPdfLoaded;
            },
            async renderPDFPages(pdfBytes) {
                UI.showLoading('A renderizar páginas...');
                try {
                    const pdfData = new Uint8Array(pdfBytes);
                    appState.pdfDocOriginal = await pdfjsLib.getDocument({ data: pdfData }).promise;
                    DOM.pdfContainer.innerHTML = '';
                    appState.selectedPageIndices.clear();

                    const renderPromises = [];
                    for (let i = 0; i < appState.pdfDocOriginal.numPages; i++) {
                        renderPromises.push(this.createPageElement(i));
                    }
                    await Promise.all(renderPromises);

                } catch (error) {
                    console.error("Erro ao renderizar PDF:", error);
                    this.showModal("Falha ao renderizar o PDF. O ficheiro pode estar corrompido.");
                } finally {
                    DOM.initialMessage.classList.add('hidden');
                    this.updateButtonStates();
                    UI.hideLoading();
                }
            },
            async createPageElement(index) {
                const page = await appState.pdfDocOriginal.getPage(index + 1);
                const viewport = page.getViewport({ scale: 0.4 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page border-2 border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer m-2 inline-block hover:shadow-lg';
                pageDiv.appendChild(canvas);
                pageDiv.dataset.index = index;
                pageDiv.draggable = true;

                // Cria e adiciona o indicador de seleção (check mark)
                const selectionIndicator = document.createElement('div');
                selectionIndicator.className = 'selection-indicator';
                selectionIndicator.innerHTML = `<i class="fas fa-check"></i>`;
                pageDiv.appendChild(selectionIndicator);

                // Cria e adiciona o número da página
                const pageNumber = document.createElement('div');
                pageNumber.className = 'page-number';
                pageNumber.textContent = index + 1;
                pageDiv.appendChild(pageNumber);

                pageDiv.addEventListener('click', EventHandlers.onPageClick);
                pageDiv.addEventListener('dragstart', EventHandlers.onDragStart);
                pageDiv.addEventListener('dragover', EventHandlers.onDragOver);
                pageDiv.addEventListener('dragleave', EventHandlers.onDragLeave);
                pageDiv.addEventListener('drop', EventHandlers.onDropOnPage);
                pageDiv.addEventListener('dragend', EventHandlers.onDragEnd);
                
                DOM.pdfContainer.appendChild(pageDiv);
                await page.render({ canvasContext: context, viewport }).promise;
            },
            loadTheme() {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                    DOM.htmlEl.classList.add('dark');
                    DOM.themeToggle.innerHTML = '☀️';
                } else {
                    DOM.htmlEl.classList.remove('dark');
                    DOM.themeToggle.innerHTML = '🌙';
                }
            },
            setSignature() {
                const year = new Date().getFullYear();
                DOM.signature.textContent = `Feito por HAlexandre © ${year}`;
            },
            download(bytes, defaultName) {
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                let fileName = DOM.fileNameInput.value.trim() || defaultName;
                if (!fileName.toLowerCase().endsWith('.pdf')) fileName += '.pdf';
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }
        };

        const EventHandlers = {
            preventDefaults(e) { e.preventDefault(); e.stopPropagation(); },
            onPageClick(e) {
                const pageDiv = e.currentTarget;
                const clickedIndex = parseInt(pageDiv.dataset.index);
                if (appState.selectedPageIndices.has(clickedIndex)) {
                    appState.selectedPageIndices.delete(clickedIndex);
                    pageDiv.classList.remove('selected');
                } else {
                    appState.selectedPageIndices.add(clickedIndex);
                    pageDiv.classList.add('selected');
                }
                UI.updateButtonStates();
            },
            onDragStart(e) {
                const pageElement = e.target.closest('.pdf-page');
                if (!pageElement) return;
                appState.draggedPageIndex = parseInt(pageElement.dataset.index);
                setTimeout(() => pageElement.classList.add('dragging'), 0);
            },
            onDragOver(e) { e.preventDefault(); e.target.closest('.pdf-page')?.classList.add('drag-over'); },
            onDragLeave(e) { e.target.closest('.pdf-page')?.classList.remove('drag-over'); },
            onDropOnPage(e) {
                e.preventDefault();
                const targetElement = e.target.closest('.pdf-page');
                if (!targetElement) return;
                targetElement.classList.remove('drag-over');
                const toIndex = parseInt(targetElement.dataset.index);
                const fromIndex = appState.draggedPageIndex;
                
                if (fromIndex !== null && toIndex !== null && fromIndex !== toIndex) {
                    UI.showLoading('A reordenar páginas...');
                    appState.pdfWorker.postMessage({ type: 'REORDER', payload: { fromIndex, toIndex } });
                }
            },
            onDragEnd(e) {
                const pageElement = e.target.closest('.pdf-page');
                if (pageElement) pageElement.classList.remove('dragging');
                appState.draggedPageIndex = null; 
            },
            onDropOnContainer(e) {
                EventHandlers.preventDefaults(e);
                DOM.pdfContainerWrapper.classList.remove('drop-zone-highlight');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
                if (files.length > 0) {
                    UI.showLoading('A carregar ficheiros...');
                    appState.pdfWorker.postMessage({ type: 'LOAD_FILES', payload: { files } });
                } else {
                    UI.showModal("Por favor, solte apenas ficheiros PDF válidos.");
                }
            },
            setup() {
                try {
                    const workerBlob = new Blob([document.getElementById('pdfWorker').textContent], { type: 'application/javascript' });
                    appState.pdfWorker = new Worker(URL.createObjectURL(workerBlob));
                    appState.pdfWorker.onmessage = (event) => {
                        const { type, payload } = event.data;
                        switch (type) {
                            case 'LOAD_SUCCESS':
                                UI.renderPDFPages(payload.pdfBytes);
                                break;
                            case 'OPERATION_SUCCESS':
                                UI.renderPDFPages(payload.pdfBytes);
                                if (payload.message) UI.showModal(payload.message);
                                break;
                            case 'SPLIT_SUCCESS':
                                UI.hideLoading();
                                UI.download(payload.pdfBytes, 'pdf_dividido.pdf');
                                UI.showModal('Novo PDF criado com sucesso!');
                                break;
                            case 'SAVE_SUCCESS':
                                UI.hideLoading();
                                UI.download(payload.pdfBytes, 'pdf_editado.pdf');
                                UI.showModal("PDF salvo com sucesso!");
                                break;
                            case 'PROGRESS':
                                UI.showLoading(payload.message);
                                break;
                            case 'ERROR':
                                UI.hideLoading();
                                UI.showModal(`Erro: ${payload.message}`);
                                break;
                        }
                    };
                    appState.pdfWorker.onerror = (error) => {
                        console.error("Erro fatal no Web Worker:", error);
                        UI.hideLoading();
                        UI.showModal("Ocorreu um erro crítico no processamento em segundo plano. Por favor, recarregue a página.");
                    };
                } catch (e) {
                    console.error("Erro ao iniciar o Web Worker:", e);
                    UI.showModal("O seu navegador não suporta Web Workers ou ocorreu um erro. A aplicação pode não funcionar corretamente.");
                }

                DOM.importInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        UI.showLoading('A carregar ficheiros...');
                        appState.pdfWorker.postMessage({ type: 'LOAD_FILES', payload: { files: Array.from(e.target.files) } });
                    }
                    e.target.value = '';
                });
                
                const getSelectedIndicesArray = () => Array.from(appState.selectedPageIndices);

                DOM.buttons.rotateClockwise.addEventListener('click', () => {
                    UI.showLoading('A girar páginas...');
                    appState.pdfWorker.postMessage({ type: 'ROTATE', payload: { indices: getSelectedIndicesArray(), angle: 90 } });
                });
                DOM.buttons.rotateCounterClockwise.addEventListener('click', () => {
                    UI.showLoading('A girar páginas...');
                    appState.pdfWorker.postMessage({ type: 'ROTATE', payload: { indices: getSelectedIndicesArray(), angle: -90 } });
                });
                DOM.buttons.remove.addEventListener('click', () => {
                    UI.showLoading('A remover páginas...');
                    appState.pdfWorker.postMessage({ type: 'REMOVE', payload: { indices: getSelectedIndicesArray() } });
                });
                DOM.buttons.split.addEventListener('click', () => {
                     UI.showLoading('A dividir PDF...');
                    appState.pdfWorker.postMessage({ type: 'SPLIT', payload: { indices: getSelectedIndicesArray() } });
                });
                DOM.buttons.replace.addEventListener('click', () => {
                    if (appState.selectedPageIndices.size !== 1) return UI.showModal("Selecione uma única página para substituir.");
                    const tempInput = document.createElement('input');
                    tempInput.type = 'file';
                    tempInput.accept = '.pdf';
                    tempInput.onchange = (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        UI.showLoading('A substituir página...');
                        const index = getSelectedIndicesArray()[0];
                        appState.pdfWorker.postMessage({ type: 'REPLACE', payload: { index, file } });
                    };
                    tempInput.click();
                });
                DOM.buttons.download.addEventListener('click', () => {
                    UI.showLoading('A salvar PDF...');
                    appState.pdfWorker.postMessage({ type: 'SAVE' });
                });

                DOM.modal.closeButton.addEventListener('click', UI.hideModal);
                DOM.themeToggle.addEventListener('click', () => {
                    DOM.htmlEl.classList.toggle('dark');
                    const isDark = DOM.htmlEl.classList.contains('dark');
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                    DOM.themeToggle.innerHTML = isDark ? '☀️' : '🌙';
                });

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    document.body.addEventListener(eventName, EventHandlers.preventDefaults, false);
                });
                DOM.pdfContainerWrapper.addEventListener('dragenter', () => DOM.pdfContainerWrapper.classList.add('drop-zone-highlight'), false);
                DOM.pdfContainerWrapper.addEventListener('dragleave', () => DOM.pdfContainerWrapper.classList.remove('drop-zone-highlight'), false);
                DOM.pdfContainerWrapper.addEventListener('drop', EventHandlers.onDropOnContainer, false);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            UI.updateButtonStates();
            UI.loadTheme();
            UI.setSignature();
            EventHandlers.setup();
        });
    </script>
</body>
</html>


